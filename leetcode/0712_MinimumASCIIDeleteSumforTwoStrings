class Solution {
    /*
    这道题给了我们两个字符串，让我们删除一些字符使得两个字符串相等，我们希望删除的字符的ASCII码最小。
    这道题跟之前那道583 - Delete Operation for Two Strings极其类似，那道题让求删除的最少的字符数，这道题换成了ASCII码值。
    其实很多大厂的面试就是这种改动，虽然很少出原题，但是这种小范围的改动却是很经常的，所以当背题侠是没有用的，必须要完全掌握了解题思想，并能举一反三才是最重要的。
    对于这种玩字符串，并且是求极值的问题，十有八九都是用dp来解的;
    
    想都不要想直接上DP，我们建立一个二维数组dp，其中dp[i][j]表示字符串s1的前i个字符和字符串s2的前j个字符变相等所要删除的字符的最小ASCII码累加值。
    那么我们可以先初始化边缘，即有一个字符串为空的话，那么另一个字符串有多少字符就要删多少字符，才能变空字符串。
    所以我们初始化dp[0][j]和dp[i][0]，计算方法就是上一个dp值加上对应位置的字符，有点像计算累加数组的方法，由于字符就是用ASCII表示的，
    所以我们不用转int，直接累加就可以。这里把dp[i][0]的计算放入大的循环中计算，是为了少写一个for循环。
    现在来看递推公式，需要遍历这个二维数组的每一个位置即dp[i][j]，当对应位置的字符相等时，s1[i-1] == s2[j-1]，(注意由于dp数组的i和j是从1开始的，
    所以字符串中要减1)，那么直接赋值为上一个状态的dp值，即dp[i-1][j-1]，因为已经匹配上了，不用删除字符。
    如果s1[i-1] != s2[j-1]，那么就有两种情况，我们可以删除s[i-1]的字符，且加上被删除的字符的ASCII码到上一个状态的dp值中，
    即dp[i-1][j] + s1[i-1]，或者删除s[j-1]的字符，且加上被删除的字符的ASCII码到上一个状态的dp值中，即dp[i][j-1] + s2[j-1]。
   比如sea和eat，当首字符s和e失配了，那么有两种情况，要么删掉s，用ea和eat继续匹配，或者删掉e，用sea和at继续匹配，
   记住删掉的字符一定要累加到dp值中才行，
    
    */
    public int minimumDeleteSum(String s1, String s2) {
        int [][] dp = new int[s1.length()+1][s2.length()+1];
        for (int i = 0; i < s1.length()+1; i++) {
            for (int j = 0; j < s2.length()+1; j++) {
                if (i == 0 && j == 0) {//矩阵第一个数字
                    dp[i][j] = 0;
                } else if (i == 0) {//第一行
                    dp[i][j] = s2.charAt(j-1) + dp[i][j-1];
                } else if (j == 0) {//第一列
                    dp[i][j] = s1.charAt(i-1) + dp[i-1][j];
                } else if (s1.charAt(i-1) == s2.charAt(j-1)) {//两个字母相等，不用删除字符并把删掉的加到总数里面
                    dp[i][j] = dp[i-1][j-1];
                } else {
                    dp[i][j] = Math.min(s1.charAt(i-1) + dp[i-1][j], s2.charAt(j-1) + dp[i][j-1]);//最小的ASCII值
                }
            }
        }
        return dp[s1.length()][s2.length()];
    }
}
