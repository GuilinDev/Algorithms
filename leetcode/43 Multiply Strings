class Solution {
    public String multiply(String num1, String num2) {
        /*
        题意: 给两个字符串型的数字，给这两个数字做乘法。
         
        如果直接转换成Integer做乘法就会溢出，所以每次都要两个single digit相乘，最大81，不会溢出；
        比如385 * 97, 就是个位=5 * 7，十位=8 * 7 + 5 * 9 ，百位=3 * 7 + 8 * 9 …
        可以每一位用一个Int表示，存在一个int[]里面；
        这个数组最大长度是num1.len + num2.len，比如99 * 99，最大不会超过10000，所以4位就够了。
        这种个位在后面的，不好做（10的0次方，可惜对应位的数组index不是0而是n-1），所以干脆先把string reverse了代码就清晰好多。
        最后结果前面的0要清掉。
        
        
        这是道数值操作的题目，考察乘法运算的本质。基本思路是和加法运算还是近似的，只是进位和结果长度复杂一些。我们仍然是从低位到高位对每一位进行计算，假设第一个数长度是n，第二个数长度是m，我们知道结果长度为m+n或者m+n-1（没有进位的情况，比如10×20结果为三位数，10×5结果为两位数）。对于某一位i，要计算这个位上的数字，我们需要对所有能组合出这一位结果的位进行乘法，即第1位和第i位，第2位和第i-1位，... ，然后累加起来，最后我们取个位上的数值，然后剩下的作为进位放到下一轮循环中(剩下的就是乘法的进位)。这个算法两层循环，每层循环次数是O(m+n)，所以时间复杂度是O((m+n)^2)。算法中不需要额外空间，只需要维护一个进位变量即可，所以空间复杂度是O(1)。
        */
        
        if(num1 == null || num2 == null || num1.length() == 0 || num2.length() == 0) {
            return "";
        }
        if (num1.charAt(0) == '0') {
            return "0";
        }
        if (num2.charAt(0) == '0') {
            return "0";
        }
        
        StringBuilder res = new StringBuilder();
        int num = 0;
        
        for (int i = num1.length() + num2.length(); i > 0; i--) {//先从个位开始算，存到左边
            for (int j = Math.min(i-1,num1.length()); j > 0; j--) { //
                if (i-j <= num2.length()) {//
                    num += (int)(num1.charAt(j-1)-'0')*(int)(num2.charAt(i-1-j)-'0'); // '0'- 48,'9' - 57；减去'0'得到字符的数值
                }
            }
            if (i != 1 || num > 0) { //看最高一位是不是0（最高第二位不可能是0，除非两个源字符串最高位带有0）
                res.append(num%10); //取个位上的数字存入，存储从左到右
            }
            num /= 10; //乘法的进位放到下一轮
        }
        return res.reverse().toString(); //由低位到高位放入结果串的，所以最后要进行一次reverse，因为是一个O(m+n)的操作，不会影响算法复杂度。
    }

    //更优的解法：十大最牛的算法之一--Fast Fourier transform(FFT)。使用FFT可以在O(nlogn)时间内求出多项式的乘法，在这里只需要把变量x带入10，然后按照求多项式的方法就可以求出两个大整数的成绩了。搜索快速傅里叶变换求多项式乘积就可以找到相关资料了，是比较成熟的算法。不过FFT实现不是很简单，所以在面试中一般不需要写代码，只需要知道这个思路和基本工作原理就可以了。
}
