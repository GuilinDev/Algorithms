class Solution {
    /*
    http://blog.csdn.net/jmspan/article/details/51688907
    此题和CareerCup中的马戏团是同一个问题，参见《Cracking the Coding Interview, 6th Edition》第17.8题。
这道题的关键在于能否看出是一个求最长公共子序列的问题

方法三：先对宽度进行排序，再应用最长递增子序列的方法，寻找高度递增的最大长度。
    */
    public int maxEnvelopes(int[][] envelopes) {
        Arrays.sort(envelopes, new Comparator<int[]>() {  
            @Override  
            public int compare(int[] e1, int[] e2) {  
                if (e1[0] != e2[0]) {
                    return e1[0] - e2[0];  
                }
                return e2[1] - e1[1];  
            }  
        });  
        
        int len = 0;
        int[] h = new int[envelopes.length];
        for (int[] envelope: envelopes) {
            int i = 0, j = len - 1;
            while (i <= j) {
                int m = (i+j)/2;
                if (h[m] < envelope[1]) {
                    i = m + 1;
                } else {
                    j = m - 1;
                }
            }
            h[i] = envelope[1];
            if ( i == len) {
                len++;
            }
        }
        return len;
    }
}
